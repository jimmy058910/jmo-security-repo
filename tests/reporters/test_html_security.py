#!/usr/bin/env python3
"""
Security tests for HTML dashboard headers (MEDIUM-002 fix).

Tests cover:
- Content Security Policy (CSP) presence and configuration
- X-Frame-Options header to prevent clickjacking
- X-Content-Type-Options to prevent MIME sniffing
- Referrer-Policy to prevent information leakage
- Robots meta tag to prevent indexing
- CSP directive validation (no unsafe directives)
- Integration with existing HTML escaping
"""

import pytest
import re
from scripts.core.reporters.html_reporter import write_html


class TestSecurityHeaders:
    """Test security headers in generated HTML dashboard."""

    @pytest.fixture
    def sample_findings(self):
        """Minimal findings for testing."""
        return [
            {
                "schemaVersion": "1.2.0",
                "id": "test-finding-1",
                "ruleId": "TEST-001",
                "severity": "HIGH",
                "message": "Test security finding",
                "tool": {"name": "test-tool", "version": "1.0.0"},
                "location": {"path": "test.py", "startLine": 10},
            }
        ]

    @pytest.fixture
    def generated_html(self, tmp_path, sample_findings):
        """Generate HTML dashboard and return its content."""
        out_path = tmp_path / "dashboard.html"
        write_html(sample_findings, out_path)
        return out_path.read_text()

    def test_csp_header_present(self, generated_html):
        """CSP meta tag should be present."""
        assert 'http-equiv="Content-Security-Policy"' in generated_html
        assert "content=" in generated_html

    def test_csp_default_src_self(self, generated_html):
        """CSP should restrict default-src to 'self'."""
        # Extract CSP content
        csp_match = re.search(
            r'http-equiv="Content-Security-Policy"\s+content="([^"]+)"', generated_html
        )
        assert csp_match, "CSP header not found"
        csp_content = csp_match.group(1)

        # Check default-src is restricted
        assert "default-src 'self'" in csp_content

    def test_csp_blocks_external_scripts(self, generated_html):
        """CSP should not allow external script sources."""
        csp_match = re.search(
            r'http-equiv="Content-Security-Policy"\s+content="([^"]+)"', generated_html
        )
        assert csp_match
        csp_content = csp_match.group(1)

        # SECURITY: Should NOT contain 'unsafe-eval' (allows eval(), very dangerous)
        assert "'unsafe-eval'" not in csp_content

        # SECURITY: script-src should be restricted (allows unsafe-inline for embedded JS)
        assert "script-src" in csp_content
        assert "'self'" in csp_content

    def test_csp_frame_ancestors_none(self, generated_html):
        """CSP should prevent iframe embedding via frame-ancestors."""
        csp_match = re.search(
            r'http-equiv="Content-Security-Policy"\s+content="([^"]+)"', generated_html
        )
        assert csp_match
        csp_content = csp_match.group(1)

        # SECURITY: frame-ancestors 'none' prevents clickjacking
        assert "frame-ancestors 'none'" in csp_content

    def test_csp_object_src_none(self, generated_html):
        """CSP should block object/embed tags to prevent Flash/plugin attacks."""
        csp_match = re.search(
            r'http-equiv="Content-Security-Policy"\s+content="([^"]+)"', generated_html
        )
        assert csp_match
        csp_content = csp_match.group(1)

        # SECURITY: object-src 'none' blocks <object>, <embed>, <applet>
        assert "object-src 'none'" in csp_content

    def test_csp_base_uri_self(self, generated_html):
        """CSP should restrict base tag to prevent base tag hijacking."""
        csp_match = re.search(
            r'http-equiv="Content-Security-Policy"\s+content="([^"]+)"', generated_html
        )
        assert csp_match
        csp_content = csp_match.group(1)

        # SECURITY: base-uri 'self' prevents base tag injection
        assert "base-uri 'self'" in csp_content

    def test_csp_connect_src_includes_api(self, generated_html):
        """CSP should allow connections to API endpoint for email submission."""
        csp_match = re.search(
            r'http-equiv="Content-Security-Policy"\s+content="([^"]+)"', generated_html
        )
        assert csp_match
        csp_content = csp_match.group(1)

        # SECURITY: connect-src should include api.jmotools.com for email form
        assert "connect-src" in csp_content
        assert "https://api.jmotools.com" in csp_content

    def test_x_frame_options_present(self, generated_html):
        """X-Frame-Options header should be present to prevent clickjacking."""
        assert 'http-equiv="X-Frame-Options"' in generated_html
        assert 'content="DENY"' in generated_html

    def test_x_frame_options_deny(self, generated_html):
        """X-Frame-Options should be set to DENY (strongest protection)."""
        # Extract X-Frame-Options content
        xfo_match = re.search(
            r'http-equiv="X-Frame-Options"\s+content="([^"]+)"', generated_html
        )
        assert xfo_match, "X-Frame-Options header not found"
        xfo_content = xfo_match.group(1)

        # SECURITY: DENY is stronger than SAMEORIGIN (blocks all framing)
        assert xfo_content == "DENY"

    def test_x_content_type_options_present(self, generated_html):
        """X-Content-Type-Options header should be present."""
        assert 'http-equiv="X-Content-Type-Options"' in generated_html
        assert 'content="nosniff"' in generated_html

    def test_x_content_type_options_nosniff(self, generated_html):
        """X-Content-Type-Options should be set to nosniff."""
        # Extract X-Content-Type-Options content
        xcto_match = re.search(
            r'http-equiv="X-Content-Type-Options"\s+content="([^"]+)"',
            generated_html,
        )
        assert xcto_match, "X-Content-Type-Options header not found"
        xcto_content = xcto_match.group(1)

        # SECURITY: nosniff prevents MIME type confusion attacks
        assert xcto_content == "nosniff"

    def test_referrer_policy_present(self, generated_html):
        """Referrer-Policy meta tag should be present."""
        assert 'name="referrer"' in generated_html
        assert "content=" in generated_html

    def test_referrer_policy_no_referrer(self, generated_html):
        """Referrer-Policy should be set to no-referrer (strongest protection)."""
        # Extract referrer policy content
        ref_match = re.search(r'name="referrer"\s+content="([^"]+)"', generated_html)
        assert ref_match, "Referrer policy not found"
        ref_content = ref_match.group(1)

        # SECURITY: no-referrer prevents information leakage
        assert ref_content == "no-referrer"

    def test_robots_meta_tag_present(self, generated_html):
        """Robots meta tag should be present to prevent indexing."""
        assert 'name="robots"' in generated_html
        assert "noindex" in generated_html
        assert "nofollow" in generated_html

    def test_robots_meta_tag_noindex_nofollow(self, generated_html):
        """Robots meta tag should prevent indexing and following links."""
        # Extract robots content
        robots_match = re.search(r'name="robots"\s+content="([^"]+)"', generated_html)
        assert robots_match, "Robots meta tag not found"
        robots_content = robots_match.group(1)

        # SECURITY: Prevents security reports from appearing in search engines
        assert "noindex" in robots_content
        assert "nofollow" in robots_content


class TestSecurityHeadersOrder:
    """Test that security headers appear early in <head> section."""

    @pytest.fixture
    def generated_html(self, tmp_path):
        """Generate HTML dashboard."""
        findings = [
            {
                "id": "test",
                "ruleId": "TEST",
                "severity": "HIGH",
                "message": "Test",
                "tool": {"name": "test", "version": "1.0.0"},
                "location": {"path": "test.py", "startLine": 1},
            }
        ]
        out_path = tmp_path / "dashboard.html"
        write_html(findings, out_path)
        return out_path.read_text()

    def test_security_headers_before_title(self, generated_html):
        """Security headers should appear before <title> for early parsing."""
        # Find positions
        csp_pos = generated_html.find('http-equiv="Content-Security-Policy"')
        title_pos = generated_html.find("<title>")

        assert csp_pos != -1, "CSP header not found"
        assert title_pos != -1, "Title not found"
        assert csp_pos < title_pos, "CSP should appear before title"

    def test_security_headers_in_head_section(self, generated_html):
        """All security headers should be in <head> section."""
        # Extract <head> section
        head_match = re.search(r"<head>(.*?)</head>", generated_html, re.DOTALL)
        assert head_match, "Head section not found"
        head_content = head_match.group(1)

        # All security headers must be in <head>
        assert 'http-equiv="Content-Security-Policy"' in head_content
        assert 'http-equiv="X-Frame-Options"' in head_content
        assert 'http-equiv="X-Content-Type-Options"' in head_content
        assert 'name="referrer"' in head_content
        assert 'name="robots"' in head_content


class TestCSPDirectiveValidation:
    """Detailed CSP directive validation tests."""

    @pytest.fixture
    def csp_content(self, tmp_path):
        """Extract CSP content from generated HTML."""
        findings = [
            {
                "id": "test",
                "ruleId": "TEST",
                "severity": "HIGH",
                "message": "Test",
                "tool": {"name": "test", "version": "1.0.0"},
                "location": {"path": "test.py", "startLine": 1},
            }
        ]
        out_path = tmp_path / "dashboard.html"
        write_html(findings, out_path)
        html = out_path.read_text()
        csp_match = re.search(
            r'http-equiv="Content-Security-Policy"\s+content="([^"]+)"', html
        )
        return csp_match.group(1) if csp_match else ""

    def test_csp_has_required_directives(self, csp_content):
        """CSP should include all critical directives."""
        required_directives = [
            "default-src",
            "script-src",
            "style-src",
            "img-src",
            "connect-src",
            "frame-ancestors",
            "base-uri",
            "object-src",
        ]

        for directive in required_directives:
            assert (
                directive in csp_content
            ), f"Missing required CSP directive: {directive}"

    def test_csp_no_wildcard_sources(self, csp_content):
        """CSP should not use wildcard (*) sources (too permissive)."""
        # SECURITY: Wildcard sources allow any origin
        assert " * " not in csp_content, "Wildcard source detected in CSP"
        assert ";*;" not in csp_content
        assert "'*'" not in csp_content

    def test_csp_style_src_allows_inline(self, csp_content):
        """CSP style-src should allow 'unsafe-inline' for embedded styles."""
        # NOTE: This is acceptable since we use embedded CSS (no external stylesheets)
        assert "style-src" in csp_content
        # Allow either 'unsafe-inline' or 'self' for styles
        assert "'unsafe-inline'" in csp_content or "'self'" in csp_content

    def test_csp_img_src_allows_data_uris(self, csp_content):
        """CSP img-src should allow data: URIs for inline images."""
        # Check img-src allows data: for base64 images
        assert "img-src" in csp_content
        assert "data:" in csp_content

    def test_csp_form_action_restricted(self, csp_content):
        """CSP form-action should be restricted to trusted endpoints."""
        assert "form-action" in csp_content
        # Should allow self and API endpoint only
        assert "https://api.jmotools.com" in csp_content or "'self'" in csp_content


class TestSecurityIntegrationWithHTMLEscaping:
    """Ensure security headers work with existing HTML escaping."""

    def test_xss_escaping_still_works(self, tmp_path):
        """HTML escaping should still work with security headers."""
        # Create finding with XSS attempt
        findings = [
            {
                "id": "xss-test",
                "ruleId": "<script>alert('XSS')</script>",
                "severity": "HIGH",
                "message": "<img src=x onerror=alert('XSS')>",
                "tool": {"name": "test", "version": "1.0.0"},
                "location": {"path": "test.py", "startLine": 1},
            }
        ]

        out_path = tmp_path / "dashboard.html"
        write_html(findings, out_path)
        html = out_path.read_text()

        # SECURITY: XSS payloads should be HTML-escaped or JSON-escaped
        # The html_reporter.py uses json.dumps() which escapes quotes as \" and special chars
        # Then applies .replace() for script tag breakouts

        # Check for dangerous unescaped patterns that would allow XSS
        # 1. Raw <script> tag not in quoted context (XSS exploit)
        # Note: json.dumps() will quote the payload, so <script>alert( won't execute
        assert "<script>alert(" not in html, "Raw <script> tag found (XSS risk)"

        # 2. Verify script tags are properly escaped in JSON data
        # The html_reporter applies .replace("</script>", "<\/script>") to prevent breakout
        # So we should find the escaped version, not the raw version
        assert (
            "<\\script>" in html or "<\\/script>" in html
        ), "Script tag not properly escaped"

        # 3. Event handlers in JSON are safe because they're quoted strings
        # "message": "<img onerror=alert()>" is NOT executable JavaScript
        # Only unquoted event handlers like <img onerror=alert()> in HTML context are dangerous
        # Since our data is in JavaScript const data = [...], the quotes protect us

        # Verify no XSS in HTML context (outside <script> tags)
        # Extract non-script HTML portions
        html_parts = re.split(r"<script[^>]*>.*?</script>", html, flags=re.DOTALL)
        html_only = "".join(html_parts)

        # In pure HTML context, these would be dangerous
        assert "<script>" not in html_only, "Unescaped <script> in HTML context"
        assert (
            "onerror=" not in html_only or 'onerror="' in html_only
        ), "Unescaped event handler in HTML"

    def test_json_breakout_prevented(self, tmp_path):
        """JSON breakout attempts should be prevented."""
        # Create finding with JSON/script breakout attempt
        findings = [
            {
                "id": "json-breakout",
                "ruleId": "TEST",
                "severity": "HIGH",
                "message": "</script><script>alert('breakout')</script><script>",
                "tool": {"name": "test", "version": "1.0.0"},
                "location": {"path": "test.py", "startLine": 1},
            }
        ]

        out_path = tmp_path / "dashboard.html"
        write_html(findings, out_path)
        html = out_path.read_text()

        # SECURITY: Script tag should be escaped in JSON
        # Check for the escaping pattern used in html_reporter.py
        assert "<\\/script>" in html or "&lt;/script&gt;" in html
        # Should NOT contain unescaped </script>
        # (allowing the one </script> that closes the main script tag)
        script_count = html.count("</script>")
        # Exactly 2: one for main script block, one for email form script
        assert script_count == 2, f"Found {script_count} </script> tags, expected 2"


class TestSecurityCommentsAndDocumentation:
    """Verify security comments are present in generated HTML."""

    def test_security_comment_present(self, tmp_path):
        """HTML should contain security comment explaining headers."""
        findings = [
            {
                "id": "test",
                "ruleId": "TEST",
                "severity": "HIGH",
                "message": "Test",
                "tool": {"name": "test", "version": "1.0.0"},
                "location": {"path": "test.py", "startLine": 1},
            }
        ]
        out_path = tmp_path / "dashboard.html"
        write_html(findings, out_path)
        html = out_path.read_text()

        # SECURITY: Comment should explain MEDIUM-002 fix
        assert "SECURITY:" in html
        assert "MEDIUM-002" in html

    def test_header_comments_explain_purpose(self, tmp_path):
        """Each security header should have explanatory comment."""
        findings = [
            {
                "id": "test",
                "ruleId": "TEST",
                "severity": "HIGH",
                "message": "Test",
                "tool": {"name": "test", "version": "1.0.0"},
                "location": {"path": "test.py", "startLine": 1},
            }
        ]
        out_path = tmp_path / "dashboard.html"
        write_html(findings, out_path)
        html = out_path.read_text()

        # Each header type should have explanatory comment
        assert "Content Security Policy" in html or "CSP" in html
        assert "clickjacking" in html or "iframe" in html
        assert "MIME sniffing" in html or "nosniff" in html
        assert "Referrer" in html or "information leakage" in html
