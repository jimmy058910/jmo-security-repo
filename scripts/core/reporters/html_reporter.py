#!/usr/bin/env python3
from __future__ import annotations
import json
from pathlib import Path
from typing import Any

# Threshold for inline vs external JSON mode
# Below this: embed JSON directly in HTML (fast, self-contained)
# Above this: load JSON via async fetch() (prevents 50-100 MB HTML files)
INLINE_THRESHOLD = 1000


def write_html(findings: list[dict[str, Any]], out_path: str | Path) -> None:
    """
    Write interactive React dashboard with dual-mode support.

    Mode selection:
    - â‰¤1000 findings: Inline mode (self-contained HTML, fast loading)
    - >1000 findings: External mode (async JSON loading, prevents browser freeze)

    Args:
        findings: List of CommonFinding dicts
        out_path: Path to write dashboard.html
    """
    p = Path(out_path)
    p.parent.mkdir(parents=True, exist_ok=True)
    total = len(findings)

    # Read the React build HTML from dist/index.html
    # This HTML is generated by `npm run build` in scripts/dashboard/
    dashboard_dir = Path(__file__).parent.parent.parent / "dashboard"
    react_build_path = dashboard_dir / "dist" / "index.html"

    if not react_build_path.exists():
        raise FileNotFoundError(
            f"React dashboard build not found at {react_build_path}. "
            f"Run 'npm run build' in {dashboard_dir}"
        )

    template = react_build_path.read_text(encoding="utf-8")

    # Decide: Inline vs External mode
    if total <= INLINE_THRESHOLD:
        # Mode 1: Inline - Embed JSON directly (self-contained, fast)
        # Escape dangerous characters that could break the <script> tag or JavaScript
        # Must escape AFTER json.dumps to avoid breaking JSON structure
        # Note: json.dumps already escapes backslashes, quotes, etc. per JSON spec
        # We only need to escape characters that break HTML <script> context:
        # 1. </script> breaks out of script tag (CRITICAL: causes premature script closure)
        # 2. <script> could inject new script tags
        # 3. <!-- could start HTML comment (breaks in some parsers)
        # 4. Backticks break JavaScript template literals (if used in JS)
        data_json = (
            json.dumps(findings)
            .replace("</script>", "<\\/script>")  # Prevent script tag breakout
            .replace("<script", "<\\script")  # Prevent script injection
            .replace("<!--", "<\\!--")  # Prevent HTML comment injection
            .replace("`", "\\`")  # Prevent template literal breakout
        )

        # Replace placeholder with inline data
        doc = template.replace(
            "window.__FINDINGS__ = []", f"window.__FINDINGS__ = {data_json}"
        )
    else:
        # Mode 2: External - Load JSON via fetch() (prevents 50-100 MB HTML files)
        # Write findings.json separately for async loading
        findings_json_path = p.parent / "findings.json"
        findings_json_path.write_text(json.dumps(findings, indent=2), encoding="utf-8")

        # Replace placeholder with fetch() call
        doc = template.replace(
            "window.__FINDINGS__ = []",
            "window.__FINDINGS__ = []  // Loaded via fetch() in App.tsx",
        )

    p.write_text(doc, encoding="utf-8")
