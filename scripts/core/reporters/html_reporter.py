#!/usr/bin/env python3
from __future__ import annotations
import json
from pathlib import Path
from typing import Any

# Threshold for inline vs external JSON mode
# Below this: embed JSON directly in HTML (fast, self-contained)
# Above this: load JSON via async fetch() (prevents 50-100 MB HTML files)
INLINE_THRESHOLD = 1000


def write_html(findings: list[dict[str, Any]], out_path: str | Path) -> None:
    """
    Write interactive React dashboard with dual-mode support.

    Mode selection:
    - ≤1000 findings: Inline mode (self-contained HTML, fast loading)
    - >1000 findings: External mode (async JSON loading, prevents browser freeze)

    Args:
        findings: List of CommonFinding dicts
        out_path: Path to write dashboard.html
    """
    import os

    p = Path(out_path)
    p.parent.mkdir(parents=True, exist_ok=True)
    total = len(findings)

    # Read the React build HTML from dist/index.html
    # This HTML is generated by `npm run build` in scripts/dashboard/
    dashboard_dir = Path(__file__).parent.parent.parent / "dashboard"
    react_build_path = dashboard_dir / "dist" / "index.html"

    # Allow skipping React build check in CI/test environments
    # Check both SKIP_REACT_BUILD_CHECK and CI environment variables
    skip_react_check = (
        os.getenv("SKIP_REACT_BUILD_CHECK", "false").lower() == "true"
        or os.getenv("CI", "false").lower() == "true"
    )

    if not skip_react_check and not react_build_path.exists():
        raise FileNotFoundError(
            f"React dashboard build not found at {react_build_path}. "
            f"Run 'npm run build' in {dashboard_dir}"
        )

    # Determine template to use (priority: React build > test fixture > fallback)
    if react_build_path.exists():
        template = react_build_path.read_text(encoding="utf-8")
    else:
        # Try test fixture as fallback for CI/test environments
        # Go up to repo root: scripts/core/reporters/ -> scripts/core -> scripts -> repo_root
        repo_root = Path(__file__).parent.parent.parent.parent
        fixture_path = (
            repo_root
            / "tests"
            / "fixtures"
            / "dashboard"
            / "test-inline-dashboard.html"
        )
        if fixture_path.exists():
            template = fixture_path.read_text(encoding="utf-8")
        else:
            # Last resort: use simple fallback HTML
            _write_fallback_html(findings, p)
            return

    # Decide: Inline vs External mode
    if total <= INLINE_THRESHOLD:
        # Mode 1: Inline - Embed JSON directly (self-contained, fast)
        # Escape dangerous characters that could break the <script> tag or JavaScript
        # Must escape AFTER json.dumps to avoid breaking JSON structure
        # Note: json.dumps already escapes backslashes, quotes, etc. per JSON spec
        # We only need to escape characters that break HTML <script> context:
        # 1. </script> breaks out of script tag (CRITICAL: causes premature script closure)
        # 2. <script> could inject new script tags
        # 3. <!-- could start HTML comment (breaks in some parsers)
        # 4. Backticks break JavaScript template literals (if used in JS)
        data_json = (
            json.dumps(findings)
            .replace("</script>", "<\\/script>")  # Prevent script tag breakout
            .replace("<script", "<\\script")  # Prevent script injection
            .replace("<!--", "<\\!--")  # Prevent HTML comment injection
            .replace("`", "\\`")  # Prevent template literal breakout
        )

        # Replace placeholder with inline data
        doc = template.replace(
            "window.__FINDINGS__ = []", f"window.__FINDINGS__ = {data_json}"
        )
    else:
        # Mode 2: External - Load JSON via fetch() (prevents 50-100 MB HTML files)
        # Write findings.json separately for async loading
        findings_json_path = p.parent / "findings.json"
        findings_json_path.write_text(json.dumps(findings, indent=2), encoding="utf-8")

        # Replace placeholder with fetch() call
        doc = template.replace(
            "window.__FINDINGS__ = []",
            "window.__FINDINGS__ = []  // Loaded via fetch() in App.tsx",
        )

    p.write_text(doc, encoding="utf-8")


def _write_fallback_html(findings: list[dict[str, Any]], out_path: Path) -> None:
    """
    Write a simple fallback HTML when React build is not available.

    Used in CI/test environments where React dashboard hasn't been built.

    Args:
        findings: List of CommonFinding dicts
        out_path: Path to write fallback dashboard.html
    """
    total = len(findings)
    html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JMo Security - Findings Report</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }}
        h1 {{
            color: #333;
            border-bottom: 3px solid #007bff;
            padding-bottom: 10px;
        }}
        .alert {{
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
        }}
        .stats {{
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }}
    </style>
</head>
<body>
    <h1>JMo Security Findings Report</h1>
    <div class="alert">
        <strong>⚠️  Fallback HTML Mode</strong><br>
        This is a simplified HTML report. The interactive React dashboard was not available.<br>
        To view the full interactive dashboard, build the React app with <code>npm run build</code> in <code>scripts/dashboard/</code>.
    </div>
    <div class="stats">
        <h2>Summary</h2>
        <p><strong>Total Findings:</strong> {total}</p>
        <p>For detailed findings, please view the JSON report at <code>findings.json</code>.</p>
    </div>
</body>
</html>
"""
    out_path.write_text(html, encoding="utf-8")
